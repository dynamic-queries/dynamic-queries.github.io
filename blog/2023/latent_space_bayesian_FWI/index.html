<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>(Original Research) Latent space Bayesian Waveform Inversion | Rahul Manavalan</title>
    <meta name="author" content="Rahul  Manavalan">
    <meta name="description" content="Waveform inversion on parsimonious models">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://dynamic-queries.github.io/blog/2023/latent_space_bayesian_FWI/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/">Rahul Manavalan</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">About</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">Projects<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">CV</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/talks/">Posters and Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/collabs/">Collaborations</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/">Teaching</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">(Original Research) Latent space Bayesian Waveform Inversion</h1>
    <p class="post-meta">July 21, 2023</p>
    <p class="post-tags">
      <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>
        ·  
        <a href="/blog/tag/inverseproblems">
          <i class="fas fa-hashtag fa-sm"></i> InverseProblems</a>  
          
        ·  
        <a href="/blog/category/projects">
          <i class="fas fa-tag fa-sm"></i> projects</a>  
          

    </p>
  </header>

  <article class="post-content">
    <h3 id="introduction">Introduction</h3>
<p>Waveform inversion concerns reconstructing velocity fields from remotely measured wave signals. It has been common practice to optimize for velocity fields parameterized as indicator functions. Considering the ill-posed nature of inversion, the trend is to turn to Bayesian inversion methods, which can be formulated as well posed problems. In addition, Bayesian methods provides one, an estimate of the uncertainity in prediction, which is ever so crucial, should waveform inversion be used for resource sensitive applications.</p>

<p>Despite all evidences pointing towards adopting Bayesian parameter estimation for waveform inversion, it is still not common practice in the FWI community; largely because Bayesian methods are extremely expensive for models with large parameters.</p>

<p>In this work, we use the time honored practice of seeking latent space representations for families of velocity fields. Subsequently we demonstrate that Bayesian waveform inversion in these latent spaces becomes computational tractable.</p>

<h3 id="latent-spaces">Latent spaces</h3>

<p>We begin with some observations. More specifically, we consider some velocity fields that are commonplace in the inversion literature – seismic and otherwise.</p>

<h4 id="fourier-space-representations">Fourier space representations</h4>
<p>Initially, we seek Fourier space latent representation of the fields. Initial observations indicate that one can do away with more than 80% of the Fourier bases functions and still obtain a qualitatively good estimate of the velocity field at the cost of mapping to and back from the Fourier space. (This is realized with <strong>fft</strong>.)</p>

<h5 id="primitives">Primitives</h5>

<style>
    .column {
  float: left;
  width: 50.00%;
  margin : 0 0 0px 0px;
  padding: 20px;
}

/* Clear floats after image containers */
.row::after {
  content: "";
  clear: both;
  display: table;
}
</style>

<div class="row">
  <div class="column">
    <img style="width:100%" src="/assets/latent/circle.svg" alt="spline-sim">
  </div>
  <div class="column">
    <img style="width:100%" src="/assets/latent/square.svg" alt="spline-sur">
  </div>
</div>

<div class="row">
   <div class="column">
    <img style="width:100%" src="/assets/latent/2circle.svg" alt="spline-sur">
    </div>
   <div class="column">
    <img style="width:100%" src="/assets/latent/circle4.svg" alt="spline-sur">
  </div>
</div>

<h5 id="velocity-classes">Velocity classes</h5>

<div class="row">
  <div class="column">
    <img style="width:100%" src="/assets/latent/simple.svg" alt="spline-sim">
  </div>
  <div class="column">
    <img style="width:100%" src="/assets/latent/complex.svg" alt="spline-sur">
  </div>
</div>

<div class="row">
   <div class="column">
    <img style="width:100%" src="/assets/latent/Csimple.svg" alt="spline-sur">
    </div>
   <div class="column">
    <img style="width:100%" src="/assets/latent/Ccomplex.svg" alt="spline-sur">
  </div>
</div>

<p>One should note that, for discontinuous functions, high frequency Fourier bases functions become increasingly relevant. While, this was not so debilitating for the examples in the Primitive section, it is clear that seismic velocity fields cannot be robustly parameterized.</p>

<h4 id="learned-latent-space-representations">Learned latent space representations</h4>

<p>This leads us to learning the latent space representations using <a href="https://arxiv.org/abs/1906.02691" rel="external nofollow noopener" target="_blank">variational autoencoders</a>.</p>

<h5 id="autoencoders">Autoencoders</h5>

<p>But let’s initially review autoencoders. Autoencoders are approximation methods for learning a latent space representation \(z\) for a given vector \(x\) in the observable space. The latent space representation is sometimes called an embedding. A generic autoencoder consists of – an encoder and a decoder (as shown below).</p>

<style>
.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 50%;
}
</style>

<p><img style="width:70%" class="center" src="/assets/latent/AE/outline.svg" alt="spline-sur"></p>

<p>Any \(x\) is hierarchically projected into a lower dimensional space upto the latent space using a dense fully connected neural network. This can also be realized using other network architectures such as CNNs and GNNs which can incorporate more inductive bias. The decoder is the mirror image of an encoder and aids in the reconstruction \(z \mapsto x\).</p>

<p>For instance, a reconstruction of the MNIST handwritten images, by sampling from the latent space and reconstructing it back, is shown below. Here \(x \in \mathbb{R}^{28 \times 28}\) and \(z \in \mathbb{R}^2\). Coincidentally, the MNIST digits can be viewed as spline shaped defects embedded in the domain of interest (similar to the primitives in the Fourier representations section.)</p>
<style>
    .columnM {
  float: left;
  width: 25.00%;
  margin : 0 0 0px 0px;
  padding: 0px;
}

/* Clear floats after image containers */
.rowM::after {
  content: "";
  clear: both;
  display: table;
}
</style>

<div class="row">
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/0.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/1.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/2.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/3.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/4.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/5.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/6.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/7.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/8.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE/9.png" alt="spline-sur">
  </div>
</div>

<p>However, autoencoders are also notoriously hard to train; with gradient based optimization algorithms trapping themselves often in local minima.</p>

<div class="row">
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/0.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/1.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/2.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/3.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/4.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/5.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/6.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/7.png" alt="spline-sur">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/8.png" alt="spline-sim">
  </div>
  <div class="columnM">
    <img style="width:100%" src="/assets/latent/AE_VF/9.png" alt="spline-sur">
  </div>
</div>

<p>This is the case with the results above, where the embeddings cannot sufficiently represent the different velocity fields faithfully. In light of this, it makes more sense to look into VAEs which have been shown to be more robust to this issue.</p>

<h5 id="variational-autoencoders">Variational Autoencoders</h5>

<p>Variational Autoencoders (VAEs) approach this representation learning problem from a Bayesian perspective. It assumes that there exists a joint probability distribution \(p(x,z)\). Then for a prior over \(z, p(z) \sim \mathcal{N}(\mu, \Sigma)\), one can find predictors for \(x\) using Bayes rule. That is,</p>

\[\begin{align}
    p(z|x) = \frac{p(x|z)\:p(z)}{p(x)}
\end{align}\]

<p>The marginal \(p(x)\) is untractable for most practical scenarios. However, one can use variational inference to estimate the posterior \(p(z|x)\) with \(q_{\theta}(z|x)\). That is, one can optimize for the parameters \(\theta\) by minimizing the Kullback-Leiber (KL) divergence between the two distributions. The backward KL divergence in this case is given by</p>

\[\begin{align}
  KL \left[q(z|x) || p(z|x)\right] := \int dz \: q(z|x) \: log\left[\frac{q(z|x)}{p(z|x)}\right]
\end{align}\]

<p>This ofcourse is intractable, since it still contains the marginal \(p(x)\). Fortunately the above expression can be re-written as follows</p>

\[\begin{align}
    EUBO := \int dz \: q(z|x) \: \left[log\left[q(x,z)\right] - log\left[q(z|x)\right]\right]  = -\int dz \: q(z|x) \: log\left[p(x)\right] +   KL \left[q(z|x) || p(z|x)\right] 
\end{align}\]

<p>Minimizing the left equation on the left hand side, also minimzes the KL divergence, since</p>

\[\begin{align}
  \int dz \: q(z|x) \: log\left[p(x)\right] \geq -EUBO 
\end{align}\]

<p>This is the evidence upper bound or the EUBO, which is actually tractable. In the context of the autoencoder,</p>

<ol>
  <li>\(q(z|x)\) is the probability distribution over predictions from the encoder.</li>
  <li>\(p(x|z)\) is the same for the decoder.</li>
  <li>\(p(z) \sim \mathcal{N}(\mu, \Sigma)\) is the prior.</li>
</ol>

<p>The general architecture of a VAE is as follows. Here, the output of the encoder is the mean \(\mu\) and the covariance matrix \(\Sigma\) of a multi-variate normal distribution \(\mathcal{N}\). The samples from \(z \sim \mathcal{N}\) constitutes the latent space variable.</p>

<p><img style="width:70%" class="center" src="/assets/latent/vae_outline.svg" alt="spline-sur"></p>

<p>Training the VAE comprises minimizing the EUBO, for which one needs to make a few assumptions.</p>


  </article>
</div>

    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Rahul  Manavalan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
